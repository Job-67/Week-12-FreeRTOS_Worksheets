## คำถามทบทวน

### 1. Timer Command Queue คืออะไร และจะเกิดอะไรขึ้นถ้ามันเต็ม?

*   **Timer Command Queue** คือ Queue ที่ Task ของผู้ใช้ใช้ในการส่ง "คำสั่ง" (เช่น `xTimerStart`, `xTimerStop`, `xTimerChangePeriod`) ไปยัง **Timer Service Task** ซึ่งเป็น Task กลางที่จัดการ Software Timer ทั้งหมด
*   **จะเกิดอะไรขึ้นถ้ามันเต็ม?:** หาก Task ของผู้ใช้พยายามส่งคำสั่งในขณะที่ Queue นี้เต็ม (ซึ่งอาจเกิดจาก Timer Service Task กำลังยุ่งกับการประมวลผล Callback ที่ทำงานนาน) Task ของผู้ใช้จะเข้าสู่สถานะ Blocked เป็นเวลาเท่าที่กำหนดในพารามิเตอร์ `xTicksToWait` ของฟังก์ชันคำสั่งนั้นๆ หากครบกำหนดเวลาแล้วยังไม่สามารถส่งคำสั่งเข้า Queue ได้ ฟังก์ชันจะคืนค่า `pdFAIL` และคำสั่งนั้นจะถูกละทิ้งไป

### 2. Priority ของ Timer Service Task มีผลต่อความแม่นยำของ Timer อย่างไร?

*   Priority ของ Timer Service Task (กำหนดใน `configTIMER_TASK_PRIORITY`) มีผลโดยตรงต่อความแม่นยำ (accuracy) และความตรงต่อเวลา (timeliness) ของ Software Timer ทั้งหมดในระบบ
    *   **ถ้า Priority ต่ำเกินไป:** Timer Service Task อาจถูก Task อื่นที่มี Priority สูงกว่าเข้ามาขัดจังหวะ (preempt) ได้ง่าย ทำให้แม้ว่า Timer จะหมดเวลาแล้ว แต่ Callback ก็ยังไม่ถูกเรียกใช้ในทันที ส่งผลให้ Timer ทำงานช้ากว่าที่ควรจะเป็น (มีความแม่นยำต่ำ)
    *   **ถ้า Priority สูงเกินไป:** อาจไปขัดขวางการทำงานของ Task อื่นที่สำคัญกว่าในระบบได้
    *   **ข้อแนะนำ:** โดยทั่วไปควรตั้งค่า Priority ของ Timer Service Task ให้สูงพอที่จะรับประกันว่า Callback จะถูกเรียกใช้ตรงเวลา แต่ไม่สูงจนไปกระทบ Task ที่มีความสำคัญทาง Real-time มากกว่า

### 3. ทำไมเราจึงไม่ควร Block ใน Timer Callback และควรทำอย่างไรถ้าต้องการประมวลผลนานๆ?

*   **เหตุผลที่ไม่ควร Block:** เพราะ Callback ของ Software Timer **ทุกตัว** จะถูกเรียกทำงานใน Context ของ **Timer Service Task ซึ่งมีเพียงตัวเดียว** หากมี Callback ใดเกิดการ Block (เช่น การเรียก `vTaskDelay` หรือรอ Semaphore) จะส่งผลให้ Timer Service Task หยุดทำงานไปด้วย และไม่สามารถไปเรียกใช้ Callback ของ Timer ตัวอื่นๆ ที่อาจจะหมดเวลาแล้วได้ ซึ่งจะทำให้การทำงานของ Timer ทั้งระบบรวนและล่าช้าไปทั้งหมด
*   **วิธีแก้เมื่อต้องการประมวลผลนานๆ:** คือการใช้ Timer Callback เพียงเพื่อ **ส่งสัญญาณ (Signaling)** ไปให้ **Worker Task** ที่สร้างขึ้นมาโดยเฉพาะเพื่อทำงานนั้นๆแทน
    1.  ใน Callback ให้ทำงานน้อยที่สุด เช่น ส่งข้อความสั้นๆ เข้า Queue โดยใช้ `xQueueSendFromISR()`
    2.  สร้าง Worker Task แยกต่างหาก ให้รอรับข้อความจาก Queue นั้น (`xQueueReceive`)
    3.  เมื่อ Worker Task ได้รับข้อความ ก็ให้เริ่มการประมวลผลที่ใช้เวลานานๆ ใน Context ของ Worker Task เอง ซึ่งจะไม่กระทบกับการทำงานของ Timer Service Task

### 4. เราสามารถเปลี่ยนคาบเวลา (Period) ของ Timer ขณะที่มันทำงานอยู่ได้หรือไม่? อย่างไร?

*   **ทำได้** เราสามารถเปลี่ยนคาบเวลาของ Timer ขณะที่มันกำลังทำงานอยู่ (Active) ได้
*   **วิธีการ:** ทำได้โดยการเรียกใช้ฟังก์ชัน `xTimerChangePeriod()` (หรือ `xTimerChangePeriodFromISR()` หากเรียกจากใน Callback/ISR) ฟังก์ชันนี้จะส่งคำสั่งไปยัง Timer Command Queue เพื่อให้ Timer Service Task อัปเดตคาบเวลาใหม่ของ Timer ที่ระบุ คาบเวลาใหม่จะมีผลทันทีหลังจากที่คำสั่งนี้ถูกประมวลผล ซึ่งเป็นคุณสมบัติที่มีประโยชน์มากในการสร้างแอปพลิเคชันที่มีพฤติกรรมแบบปรับตัวได้ (Adaptive Behavior) เช่น การเปลี่ยนความถี่ในการอ่านค่าเซ็นเซอร์ตามสถานการณ์ที่เปลี่ยนแปลงไป