## คำถามทบทวน

### 1. การประยุกต์ใช้ Timer ในการสร้าง Watchdog Timer

*   **หลักการ:** เราสามารถสร้าง Software Watchdog เพื่อตรวจสอบว่าระบบยังทำงานเป็นปกติอยู่หรือไม่ โดยการใช้ **One-shot Timer**
*   **ขั้นตอนการทำงาน:**
    1.  สร้าง One-shot Timer ที่มีคาบเวลายาวๆ (เช่น 5000 ms) โดยกำหนดให้ Callback Function ของ Timer นี้เป็นฟังก์ชัน "ลงโทษ" เช่น สั่งรีเซ็ตระบบ หรือบันทึก Log ว่าระบบค้าง
    2.  เมื่อระบบทำงานเป็นปกติ Task ต่างๆ จะต้องคอย "ป้อนอาหาร" (Feed) ให้ Watchdog Timer เป็นระยะๆ (ต้องสั้นกว่าคาบเวลาของ Watchdog) โดยการเรียกใช้ `xTimerReset()`
    3.  หากระบบเกิดอาการค้างและ Task ต่างๆ หยุดทำงาน Watchdog ก็จะไม่ถูกป้อนอาหาร ทำให้ Timer ไม่ถูกรีเซ็ต และเมื่อนับครบเวลา มันจะเรียก Callback Function เพื่อจัดการกับปัญหาที่เกิดขึ้น เป็นการป้องกันไม่ให้ระบบค้างการทำงานไปตลอด

### 2. การทำ Adaptive Sampling Rate โดยใช้ Timer

*   **หลักการ:** คือการ **ปรับเปลี่ยนคาบเวลา (Period) ของ Periodic Timer แบบไดนามิก** ตามเงื่อนไขของระบบ เพื่อให้การเก็บข้อมูลมีประสิทธิภาพสูงสุด
*   **ขั้นตอนการทำงาน:**
    1.  สร้าง Periodic Timer เพื่อทำการอ่านค่าเซ็นเซอร์ใน Callback Function
    2.  ภายใน Callback หลังจากอ่านค่าได้แล้ว จะมีการนำค่าที่ได้มาประเมิน เช่น "หากอุณหภูมิสูงขึ้นอย่างรวดเร็ว" หรือ "ค่าที่ได้คงที่เป็นเวลานาน"
    3.  จากผลการประเมิน จะมีการเรียกใช้ฟังก์ชัน `xTimerChangePeriod()` หรือ `xTimerChangePeriodFromISR()` เพื่อปรับคาบเวลาของ Timer ให้เหมาะสมกับสถานการณ์ เช่น เมื่ออุณหภูมิสูงขึ้น ก็ปรับคาบเวลาให้สั้นลงเพื่อเก็บข้อมูลให้ถี่ขึ้น แต่ถ้าอุณหภูมิคงที่ ก็ปรับคาบเวลาให้นานขึ้นเพื่อประหยัดพลังงาน

### 3. ทำไมจึงควรใช้ Timer ในการ Poll Sensor แทนการใช้ `vTaskDelay` ใน Loop?

*   **ประหยัดทรัพยากรมากกว่า:** การสร้าง Task 1 ตัวเพื่อวนลูป `vTaskDelay` จะต้องมีการจองหน่วยความจำสำหรับ Stack ของ Task นั้นๆ ซึ่งสิ้นเปลืองกว่ามากเมื่อเทียบกับการใช้ Software Timer ที่ทุกตัวใช้ Stack ร่วมกันใน Timer Service Task สำหรับงานง่ายๆ ที่ทำซ้ำเป็นเวลา การสร้าง Task ทั้งตัวจึงเป็นการสิ้นเปลืองโดยใช่เหตุ
*   **จัดการง่ายและเป็นระบบกว่า:** การควบคุม Timer (เช่น สั่งหยุด, เริ่ม, เปลี่ยนคาบเวลา) ผ่าน API ของ Timer ทำได้ง่ายและเป็นระบบกว่าการที่จะต้องไปจัดการ Task หลายๆ ตัวที่ทำงานแยกจากกัน
*   **โค้ดเรียบง่ายกว่า:** สำหรับงานง่ายๆ ที่ทำซ้ำเป็นเวลา การสร้าง Timer และ Callback สั้นๆ จะทำให้โค้ดดูสะอาดและเข้าใจง่ายกว่าการสร้าง Task ทั้งตัวที่มี `while(1)` loop อยู่ข้างใน

### 4. Timer ID มีประโยชน์อย่างไรในการสร้างแอปพลิเคชันที่ซับซ้อน?

*   **ประโยชน์หลัก:** Timer ID ทำให้เรา **สามารถใช้ Callback Function เดียวกันในการจัดการ Timer หลายๆ ตัวได้** ซึ่งช่วยลดการเขียนโค้ดซ้ำซ้อนและจัดระเบียบโปรแกรมได้ดีขึ้น
*   **วิธีใช้:**
    1.  ตอนที่สร้าง Timer แต่ละตัวด้วย `xTimerCreate()` เราสามารถกำหนด ID ที่ไม่ซ้ำกัน (เช่น หมายเลข 1, 2, 3 หรือ pointer) ให้กับ Timer แต่ละตัวได้
    2.  จากนั้นใน Callback Function เราสามารถเรียก `pvTimerGetTimerID()` เพื่อสอบถามว่า Timer ตัวไหนที่เพิ่งหมดเวลาลง
    3.  ใช้ `switch-case` หรือ `if-else` เพื่อแยกการทำงานตาม ID ที่ได้รับ ทำให้ Callback Function เดียวสามารถรองรับการทำงานที่แตกต่างกันของ Timer หลายๆ ตัวได้